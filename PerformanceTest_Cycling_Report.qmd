---
title: "PFL DATA REPORT"
format: 
  docx:
    reference-doc: 'C:/Users/bethany.kilpatrick/Boa Technology Inc/PFL - General/Testing Segments/Report_Template.docx'
editor: visual
editor_options: 
  chunk_output_type: console
execute:
  error: true 
  warning: false
---

# CONFIDENTAL CONTENT FOR BOA EMPLOYEES ONLY. PLEASE CONTACT PFL DIRECTLY WITH ANY QUESTIONS.

+--------------------+--------------------------------------+
| Test Name          | PP_CyclingUpperStiffnessIII_July2024 |
+====================+======================================+
| **Benefit:**       | Cycling                              |
+--------------------+--------------------------------------+
| **Date:**          | 08/2024                              |
+--------------------+--------------------------------------+
| **Test Type:**     | Performance                          |
+--------------------+--------------------------------------+
| **Configurations** | Baseline: High Stiffness (High)      |
|                    |                                      |
|                    | Test configurations:                 |
|                    |                                      |
|                    | -   Medium Stiffness (Mid)           |
|                    |                                      |
|                    | -   Low Stiffness (Low)              |
+--------------------+--------------------------------------+

## Purpose & Background

-   Previous cycling performance tests

-   The purpose of this test was to evaluate

## Hypothesis

H1:

H2:

H1.

## Methods

+------------------+---------------------------+----------------------------+------------------------------------------+
| Subjects         | Movements                 | Equipment                  | Measurements                             |
+==================+===========================+============================+==========================================+
| 9 Male Athletes  | -   Steady aerobic riding | -   Cycle ergometer        | Endurance & Health:                      |
|                  |                           |                            |                                          |
| 1 Female Athlete | -   10 s sprint           | -   Pressure insoles:      | -   Heel contact throughout the upstroke |
|                  |                           |                            |                                          |
|                  |                           |     -   Plantar and dorsal | Power & Precision:                       |
|                  |                           |                            |                                          |
|                  |                           |                            | -   Power Output                         |
+------------------+---------------------------+----------------------------+------------------------------------------+

## Configurations

| A   | B   | C   |
|-----|-----|-----|
|     |     |     |

## Summary

## Next Steps

```{r}
#| echo: false
#| warning: false
#| include: false

library(readxl)
library(tidyverse)
library(tm)
library(SnowballC)
library(RColorBrewer)
library(wordcloud)
library(readxl)
library(brms)
library(patchwork)
library(tidyr)
library(fmsb)
library(gt)
library(ggplot2)
library(ggpubr)
rm(list=ls())
```

```{r}
#| echo: false
#| include: false


# Watt bike power data
powerDat <- read.csv('C:\\Users\\bethany.kilpatrick\\Boa Technology Inc\\PFL Team - General\\Testing Segments\\Cycling Performance Tests\\PP_CyclingUpperStiffnessIII_Performance_Aug24\\Wattbike\\0_CompiledPowerData_sd.csv')  


massDat <- read_xlsx('C:\\Users\\bethany.kilpatrick\\Boa Technology Inc\\PFL Team - General\\Testing Segments\\Cycling Performance Tests\\PP_CyclingUpperStiffnessIII_Performance_Aug24\\PP_CyclingUpperStiffnessIII_August2024_Qual.xlsx',sheet = 'Sheet3')

#Pressure Dat during Cycling 
pressDat <- read.csv('C:\\Users\\bethany.kilpatrick\\Boa Technology Inc\\PFL - General\\Testing Segments\\Cycling Performance Tests\\PP_CyclingUpperStiffnessIII_Performance_Aug24\\Xsensor\\0_CompiledResults.csv') 


pressDatSteady <- subset(pressDat, pressDat$Movement == 'Steady')
pressDatSprint <- subset(pressDat, pressDat$Movement == 'Sprint')



staticDat <- read.csv('C:\\Users\\bethany.kilpatrick\\Boa Technology Inc\\PFL - General\\Testing Segments\\Cycling Performance Tests\\PP_CyclingUpperStiffnessIII_Performance_Aug24\\Xsensor\\Static\\0_CompiledResults_Static.csv') 



#Load in Compiled Qualitative Sheet
qualDat <- read_xlsx('C:\\Users\\bethany.kilpatrick\\Boa Technology Inc\\PFL Team - General\\Testing Segments\\Cycling Performance Tests\\PP_CyclingUpperStiffnessIII_Performance_Aug24\\PP_CyclingUpperStiffnessIII_August2024_Qual.xlsx')



baseline <- '1_Stretch' # baseline configuration

otherConfigs <- c('2_Stretch', '3_Stretch') # other configurations tested against base
allConfigs <- c(baseline, otherConfigs) 


powerDat <- as_tibble(powerDat) # creating the data frame
powerDat$Config <- factor(powerDat$Config, allConfigs)


pressDat <- as_tibble(pressDat)
pressDat$Config <- factor(pressDat$Config, allConfigs) 



staticDat <- as_tibble(staticDat)
staticDat$Config<- factor(staticDat$Config, allConfigs)


qualDat$Config <- factor(qualDat$Config, allConfigs)



withinSubPlot <- function(inputDF, colName, dir) {
  
  # direction can be 'lower' or higher'. It is the direction of change that is better. 
  # For example, for contact time lower is better. so we put 'lower'. for jump height, higher is better, so we put higher. 
  meanDat <- inputDF %>%
    group_by(Subject, Config) %>%
    summarize(mean = mean(!! sym(colName)))
  
  if (dir == 'lower'){
    whichConfig <- meanDat %>%
      group_by(Subject) %>%
      summarize(
        BestConfig = Config[which.min(mean)]
      )
    
  } else if (dir == 'higher') {
    whichConfig <- meanDat %>%
      group_by(Subject) %>% 
      summarize(
        BestConfig = Config[which.max(mean)]
      )
    
  }
  
  whichConfig <- merge(meanDat, whichConfig)
  
  ggplot(data = whichConfig, mapping = aes(x = as.factor(Config), y = mean, col = BestConfig, group = Subject)) + geom_point(size = 4) + 
    geom_line() + xlab('Configuration') + scale_color_manual(values=c("#000000","#00966C", "#ECE81A","#DC582A","#CAF0E4")) + theme(text = element_text(size = 12)) + ylab(paste0({{colName}})) 
  
}


extractVals <- function(dat, mod, configNames, baseConfig, var, dir) {
  
  Config = rep(NA, length(configNames))
  ProbImp = matrix(0, length(configNames))
  lowCI = matrix(0, length(configNames))
  highCI = matrix(0, length(configNames))
  
  for (i in 1:length(configNames)) {
    # This function takes the original dataframe (dat, same one entered into runmod), the Bayesian model from brms (runmod), 
    # the configuration Name, and the variable you are testing. It returns:
    # [1] the probabality the variable was better in the test config vs. the baseline config
    # [3] the lower bound of the bayesian 95% posterior interval (as percent change from baseline) 
    # [4] the upper bound of the bayesian 95% posterior interval (as percent change from baseline)
    #i = 1
    
    configName = configNames[i]
    configColName <- paste('b_Config', configName, sep = "")
    posterior <- posterior_samples(mod)
    
    if (dir == 'lower'){
      prob <- sum(posterior[,configColName] < 0) / length(posterior[,configColName])
      
    } else if (dir == 'higher') {
      
      prob <- sum(posterior[,configColName] > 0) / length(posterior[,configColName])
    }
    
    ci <- posterior_interval(mod, prob = 0.80)
    ciLow <- ci[configColName,1] 
    ciHigh <- ci[configColName,2]
    
    SDdat <- dat %>%
      group_by(Subject) %>%
      summarize(sd = sd(!! sym(var), na.rm = TRUE), mean = mean(!! sym(var), na.rm = TRUE))
    
    meanSD = mean(SDdat$sd , na.rm = TRUE)
    mean = mean(SDdat$mean, na.rm = TRUE)
    ci_LowPct <- meanSD*ciLow/mean*100
    ci_HighPct <- meanSD*ciHigh/mean*100
    
    output = list('Config:', configName, 'Probability of Improvement:', prob, 'Worse end of CI:', ci_LowPct, 'Best end of CI:', ci_HighPct)
    Config[i] = configName
    ProbImp[i] = prob
    lowCI[i] = ci_LowPct
    highCI[i] = ci_HighPct
  }
  ProbImp = round(ProbImp*100)
  lowCI = round(lowCI, 1)
  highCI = round(highCI,1)
  output = cbind(Config, ProbImp, lowCI, highCI)
  
  colnames(output) = c('Config', 'Probability of Improvement', 'Low end of CI', 'High end of CI')
  
  sentences = rep(NA, nrow(output))
  
  for (i in 1:nrow(output)){
    if (as.numeric(output[i,2]) >= 90){
      sentences[i] <- paste0('We have meaningful confidence that ',output[i,1], ' outperformed ', baseConfig, ' (',output[i,2], '%)', '\n', '\t', '- Estimated difference: ',output[i,3],' to ',output[i,4],'%' )
    } else if (as.numeric(output[i,2]) >= 80) {      
      sentences[i] <- paste('We have moderate confidence that',output[i,1], 'outperformed', baseConfig, '(',output[i,2], '%)','\n', '\t', '- Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 70){
      sentences[i] <- paste('We have minimal confidence that',output[i,1], 'outperformed', baseConfig, '(',output[i,2], '%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 30){
      sentences[i] <- paste('There were inconsistent differences between',output[i,1],'and',baseConfig,'(',output[i,2],'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 20){
      sentences[i] <- paste('We have minimal confidence that',output[i,1],'performed worse than',baseConfig,'(',(100 - as.numeric(output[i,2])),'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 10){
      sentences[i] <- paste('We have moderate confidence that',output[i,1],'performed worse than',baseConfig,'(',(100 - as.numeric(output[i,2])),'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else {
      sentences[i] <- paste('We have meaningful confidence that',output[i,1],'performed worse than',baseConfig,'(',(100 - as.numeric(output[i,2])),'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    }
  }
  
  writeLines(sentences)
  return()
}

# Setting up  "Best Of" line plots 
withinSubQualPlot <- function(inputDF) {
  
  # direction can be 'lower' or higher'. It is the direction of change that is better. 
  # For example, for contact time lower is better. so we put 'lower'. for jump height, higher is better, so we put higher. 
  
  whichConfig <- inputDF %>%
    group_by(Subject) %>%
    summarize(
      BestConfig = Config[which.max(OverallFit)]
    )
  
  whichConfig <- merge(inputDF, whichConfig)
  
  ggplot(data = whichConfig, mapping = aes(x = as.factor(Config), y = OverallFit, col = BestConfig, group = Subject)) + geom_point(size = 4) + 
    geom_line() + xlab('Configuration') + scale_color_manual(values=c("#000000", "#00966C", "#ECE81A","#DC582A","#CAF0E4")) + ylab('Rating') + theme(text = element_text(size = 12))
  
}

###############################
```

## **Qualitative**

```{r}
#| echo: false
#| layout-ncol: 2
#| tbl-column: page-right
#| fig-column: page-left
#| warning: false
#| fig-height: 7
#| fig-width: 4



qualDat %>%
  pivot_longer(cols = OverallFit:Heel, 
               names_to = "Location", values_to = "Rating") %>%
  group_by(Location, Config) %>%
  summarize(
    Avg = median(Rating, na.rm = TRUE) # median avg
  ) %>%
  gt()

# 
# 
qualDat <- pivot_longer(qualDat, cols = Forefoot:Heel, names_to = 'Location', values_to = 'Rating')

# FF <- qualDat %>% 
#   filter(Location=="Forefoot")

# ggplot(FF,mapping = aes(x = Rating, fill = Config, ..count.. )) + geom_density(alpha = 0.5)
  
qualDat$Location <- factor(qualDat$Location, c('Forefoot', 'Midfoot', 'Heel'))


a <- withinSubQualPlot(qualDat)



b <- ggplot(qualDat, mapping = aes(x = Rating, fill = Config)) + 
  geom_histogram(position = 'dodge', binwidth = 1) + facet_wrap(~Location) + scale_fill_manual(values=c("#999999", "#00966C", "#ECE81A","#DC582A","#CAF0E4")) +
  ylab('Responses') + theme(text=element_text(size=12)) + geom_vline(xintercept = 5, linewidth = 1) 


figs <- ggarrange(a, b, ncol = 1, nrow = 2)


figs
```

### **Dial Torque**

```{r}
#| echo: false
#| warning: false





qualDat %>%
  group_by(Config)%>%
  summarize(
    R_Torque = mean(R_DialTorque1, na.rm = TRUE),
    # R_Torque_Instep = mean(R_DialTorque1, na.rm = TRUE),
    L_Torque = mean(L_DialTorque1, na.rm = TRUE),
    # L_Torque_Instep = mean(L_DialTorque1, na.rm = TRUE)
  )%>%
  gt()


ggplot(qualDat, aes(x=Config, y = R_DialTorque1, color = Config, group= Subject)) + 
  geom_point(size = 4)+ 
  geom_line(aes(color=Config))+
  # facet_wrap(~Subject)+
  scale_color_manual(values=c("#000000","#00966C", "#ECE81A","#DC582A","#CAF0E4"))+ 
  theme(text = element_text(size = 16))+ 
  ylab('Right Dial Torque [N-cm]')+ 
  xlab('Config')+
  ggtitle('Right Foot')






torqueDat <- qualDat %>%
  group_by(Subject) %>%
  mutate(z_score = scale(R_DialTorque1)) %>%
  group_by(Config)


torqueMod <- brm(data = torqueDat, # Bayes model
              family = gaussian,
              z_score ~  Config + (1  | Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas) 
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)


extractVals(torqueDat , torqueMod, otherConfigs, baseline, 'R_DialTorque1', 'higher')

```

# Power

### **Sprint Power Output**

```{r}
#| echo: false
#| warning: false
#| include: false 


################
###############################################
 

###### 


#Joining Power and Mass to normalize sprint peak power 
jointDat <- merge(x = powerDat, y = massDat, by = c('Subject'), all.x = TRUE) 


jointDat <- transform(jointDat, normSprint = Power_sprint / Mass)


sprintDat <- jointDat%>%
  group_by(Subject) %>%
  mutate(z_score = scale(normSprint)) %>%
  group_by(Config)



ggplot(data = sprintDat, aes(x = normSprint, fill = Config)) + geom_histogram() + facet_wrap(~Subject)


sprintDatMod <- brm(data = sprintDat, # Bayes model
              family = gaussian,
              z_score ~ Config + Trial + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .999, max_treedepth = 20),
              seed = 190831)

```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 


p <- withinSubPlot(sprintDat, colName = 'normSprint', dir = 'higher')
p + ylab('Normalized Sprint Power (Watts/kg)')
#




# p+ geom_text(
#   aes(label = Subject),
#   color = "black",
#   check_overlap = TRUE)


extractVals(sprintDat, sprintDatMod, otherConfigs, baseline, 'normSprint', 'higher')
```

```{r}
#| echo: false
#| warning: false
#| include: false 


################
###############################################
 # Data checking the Steady power varience 

jointDat <- transform(jointDat, normSteadySD = Power_Steadysd / Mass)

SteadyVarDat <- jointDat %>%
  group_by(Subject) %>%
  mutate(z_score = scale(normSteadySD)) %>%
  group_by(Config)


ggplot(data = SteadyVarDat, aes(x = Power_Steadysd, fill = Config)) + geom_histogram() + facet_wrap(~Subject)

SteadyVarMod <- brm(data = SteadyVarDat, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .999, max_treedepth = 20),
              seed = 190831)



p <- withinSubPlot(SteadyVarDat, colName = 'normSteadySD', dir = 'lower')
p + ylab('Normalized Steady Power Variation (Watts)')  
# 
p+ geom_text(
  aes(label = Subject),
  color = "black",
  check_overlap = TRUE)


extractVals(SteadyVarDat, SteadyVarMod, otherConfigs, baseline, 'Power_Steadysd', 'lower') 

```

# **Quantitative Fit**

### **Instep Avg Pressure - Static - Higher is Better**

```{r}
#| echo: false
#| warning: false
#| include: false 


################
###############################################
# Dorsal Instep pressure


staticDat_instPres <- staticDat %>%
  group_by(Subject) %>%
  mutate(z_score = scale(instepDorsalPressure)) %>%
  group_by(Config)


# Look at histogram of the data if any outliers need to be removed
ggplot(data = staticDat_instPres, aes(x = instepDorsalPressure, fill = Config)) + geom_histogram() + facet_wrap(~Subject)



instDorsalMod <- brm(data = staticDat_instPres, # Bayes model
              family = gaussian,
              z_score ~ Config + Trial + (1 | Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 


p <- withinSubPlot(staticDat_instPres , colName = 'instepDorsalPressure', dir = 'higher')
p + ylab('Avg. Instep Pressure (kPa)')

extractVals(staticDat_instPres, instDorsalMod, otherConfigs, baseline, 'instepDorsalPressure', 'higher')
```

#\| echo: false

#\| warning: false

#\| layout-ncol: 2

p \<- withinSubPlot(staticDat_MAXinstPres , colName = 'maxDorsalPressure', dir = 'lower')

p + ylab('Peak Instep Pressure (kPa)')

extractVals(staticDat_MAXinstPres, MAXinstDorsalMod, otherConfigs, baseline, 'maxDorsalPressure', 'lower')

```{r}
#| echo: false
#| warning: false
#| include: false


staticDat_MAXinstPres <- staticDat %>%
  group_by(Subject) %>%
  mutate(z_score = scale(maxDorsalPressure)) %>%
  group_by(Config)


# Look at histogram of the data if any outliers need to be removed
ggplot(data = staticDat_MAXinstPres, aes(x = maxDorsalPressure, fill = Config)) + geom_histogram() + facet_wrap(~Subject)



MAXinstDorsalMod <- brm(data = staticDat_MAXinstPres, # Bayes model
              family = gaussian,
              z_score ~ Config + Trial + (1 | Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)


```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2


p <- withinSubPlot(staticDat_MAXinstPres , colName = 'maxDorsalPressure', dir = 'lower')
p + ylab('Peak Instep Pressure (kPa)')

extractVals(staticDat_MAXinstPres, MAXinstDorsalMod, otherConfigs, baseline, 'maxDorsalPressure', 'lower')
```

### Peak Toe Pressure - Dynamic - Lower is Better

```{r}
#| echo: false
#| warning: false
#| include: false 

# Plantar Max Toe Pressure

toemaxDat<- pressDat %>%
  group_by(Subject) %>%
  mutate(z_score = scale(maxmaxToes)) %>%
  group_by(Config) 

toemaxDat <- toemaxDat %>%
  group_by(Subject, Config, Order) %>%
  slice_sample(n = 50)

# 
# 
# ggplot(data = toemaxDat, aes(x = maxmaxToes, fill = Config)) + geom_histogram() + facet_wrap(~Subject)


toemaxDat <- subset(toemaxDat, toemaxDat$z_score < 2) #removing outliers
toemaxDat <- subset(toemaxDat, toemaxDat$z_score > -2)


toemaxMod <- brm(data = toemaxDat, # Bayes model
              family = gaussian,
              z_score ~ Config + Order + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 500, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 

p <- withinSubPlot(toemaxDat, colName = 'maxmaxToes', dir = 'lower')
p + ylab('Max Toe Pressure (kPa)') 
# p + geom_text(
#   aes(label = Subject),
#   color = "black",
#   check_overlap = TRUE)


extractVals(toemaxDat, toemaxMod, otherConfigs, baseline, 'maxmaxToes', 'lower')
```

### Ave Forefoot Pressure - Static

```{r}
#| echo: false
#| warning: false
#| include: false 


################
###############################################

# Dorsal Forefoot ave pressure
ffPDat<- staticDat %>%
  group_by(Subject) %>%
  mutate(z_score = scale(ffDorsalPressure)) %>%
  group_by(Config)




ggplot(data = ffPDat, aes(x = ffDorsalPressure, fill = Config)) + geom_histogram() + facet_wrap(~Subject)


ffPMod <- brm(data = ffPDat, # Bayes model
              family = gaussian,
              z_score ~ Config + Trial + (1| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 


p <- withinSubPlot(ffPDat, colName = 'ffDorsalPressure', dir = 'higher')
p + ylab('Avg Forefoot Pressure (kPa)')

extractVals(ffPDat, ffPMod, otherConfigs, baseline, 'ffDorsalPressure', 'higher')
```

### **Ave. Midfoot Pressure - Static**

```{r}
#| echo: false
#| warning: false
#| include: false 


################
###############################################
# Dorsal Midfoot ave pressure 
mfPDat<- staticDat %>%
  group_by(Subject) %>%
  mutate(z_score = scale(mfDorsalPressure)) %>%
  group_by(Config)



# 
# ggplot(data = mfPDat, aes(x = mfDorsalPressure, fill = Config)) + geom_histogram() + facet_wrap(~Subject)



mfPMod <- brm(data = mfPDat, # Bayes model
              family = gaussian,
              z_score ~ Config + Trial + (1 | Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 700, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 

p<- withinSubPlot(mfPDat, colName = 'mfDorsalPressure', dir = 'higher')
p + ylab('Avg Midfoot Pressure (kPa)')

extractVals(mfPDat, mfPMod, otherConfigs, baseline, 'mfDorsalPressure', 'higher')

```

### **Heel Contact Area - Dynamic - Higher is Better**

```{r}
#| echo: false
#| warning: false
#| include: false 


heelConDat <- pressDat %>%
  group_by(Subject) %>%
  mutate(z_score = scale(heelArea_Up)) %>%
  group_by(Config)

heelConDat <- heelConDat %>%
  group_by(Subject, Config, Order) %>%
  slice_sample(n = 50)

# 
# 
# ggplot(data = heelConDat, aes(x = heelArea_Up, fill = Config)) + geom_histogram() + facet_wrap(~Subject)


heelConDat <- subset(heelConDat, heelConDat$z_score < 2) #removing outliers
heelConDat <- subset(heelConDat, heelConDat$z_score > -2)



heelConMod <- brm(data = heelConDat, # Bayes model
              family = gaussian,
              z_score ~ Config + Order + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 500, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2  

p<- withinSubPlot(heelConDat, colName = 'heelArea_Up', dir = 'higher')

p+ ylab('Heel Contact Area - Upstroke (kPa)')
# p + geom_text(
#   aes(label = Subject),
#   color = "black",
#   check_overlap = TRUE)
extractVals(heelConDat, heelConMod, otherConfigs, baseline, 'heelArea_Up', 'higher')
```

## Center of Pressure (COP)

```{r}
#| echo: false
#| warning: false
#| include: false 




copExSteady <- pressDatSteady %>% 
  group_by(Subject) %>%
  mutate(z_score = scale(COPEx)) %>% 
  group_by(Config)





ggplot(data = copExSteady, aes(x = COPEx, fill = Config)) + geom_histogram() + facet_wrap(~Subject) 



copExSteady <- subset(copExSteady, copExSteady$z_score < 2) #removing outliers
copExSteady <- subset(copExSteady, copExSteady$z_score > -2)


copExSteadyMod <- brm(data = copExSteady, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831) 

p <- withinSubPlot(copExSteady, colName = 'COPEx', dir = 'lower')

p + ylab('Steady - Center-of-Pressure Excursion (mm)')  



extractVals(copExSteady, copExSteadyMod, otherConfigs, baseline, 'COPEx', 'lower')
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2  

p <- withinSubPlot(copExSteady, colName = 'COPEx', dir = 'lower')

p + ylab('Steady - Center-of-Pressure Excursion (mm)')  



extractVals(copExSteady, copExSteadyMod, otherConfigs, baseline, 'COPEx', 'lower')
```
