---
title: "PFL DATA REPORT"
format: 
  docx:
    reference-doc: 'C:\\Users\\eric.honert\\Boa Technology Inc\\PFL Team - General\\Testing Segments\\Report_Template.docx'
editor: visual
editor_options: 
  chunk_output_type: console
execute:
  error: true 
  warning: false
---

# CONFIDENTAL CONTENT FOR BOA EMPLOYEES ONLY. PLEASE CONTACT PFL DIRECTLY WITH ANY QUESTIONS.

+--------------------+----------------------------------------------+
| Test Name          | 2025_Performance_CyclingLacevBOA_Specialized |
+====================+==============================================+
| **Segment:**       | Cycling: Road                                |
+--------------------+----------------------------------------------+
| **Date:**          | 4/2025                                       |
+--------------------+----------------------------------------------+
| **Test Type:**     | Performance                                  |
+--------------------+----------------------------------------------+
| **Configurations** | Baseline: Lace                               |
|                    |                                              |
|                    | Test configurations:                         |
|                    |                                              |
|                    | -   BOA Dual Dial (BOA)                      |
+--------------------+----------------------------------------------+

# Purpose & Background

-   Previous cycling performance tests

-   **The purpose of this test was to evaluate**

# Hypothesis

**Key Benefits:**

H1:

H2:

**Additional Benefits:**

H3:

# Methods

+-----------------+---------------------------+----------------------------+------------------------+
| Subjects        | Movements                 | Equipment                  | Measurements           |
+=================+===========================+============================+========================+
| 9 Male Athletes | -   Steady aerobic riding | -   Metabolics             | Energy Efficiency:     |
|                 |                           |                            |                        |
|                 | -   10 s sprint           | -   Cycle ergometer        | -   Energy Expendature |
|                 |                           |                            |                        |
|                 |                           | -   Pressure insoles:      | Power Transfer:        |
|                 |                           |                            |                        |
|                 |                           |     -   Plantar and dorsal | -   Power Output       |
+-----------------+---------------------------+----------------------------+------------------------+

# Configurations

| Lace | BOA |
|------|-----|
|      |     |

```{r}
#| echo: false
#| warning: false
#| include: false
library(tidyverse)
library(lme4)
library(emmeans)
library(tm)
library(SnowballC)
library(RColorBrewer)
library(wordcloud)
library(readxl)
library(brms)
library(patchwork)
library(tidyr)
library(fmsb)
library(gt)
library(ggplot2)
library(ggpubr)
rm(list=ls())
```

```{r}
#| echo: false
#| include: false

#Load in Compiled Qualitative Sheet
qualDat <- read_xlsx('C:\\Users\\eric.honert\\Boa Technology Inc\\PFL Team - General\\Testing Segments\\Cycling Performance Tests\\2025_Performance_CyclingLacevBOA_Specialized\\2025_Performance_CyclingLacevBOA_Specialized.xlsx')

qualDat <- qualDat %>% 
  mutate(Config = replace(Config, Config == 'DD', 'BOA'))

anthroDat <- read_xlsx('C:\\Users\\eric.honert\\Boa Technology Inc\\PFL Team - General\\Testing Segments\\Cycling Performance Tests\\2025_Performance_CyclingLacevBOA_Specialized\\2025_Performance_CyclingLacevBOA_Specialized.xlsx', sheet = 'Sheet3')
anthroDat <- subset(anthroDat, select = c(Subject, Mass))

# Wahoo bike power data
powerDat <- read.csv('C:\\Users\\eric.honert\\Boa Technology Inc\\PFL Team - General\\Testing Segments\\Cycling Performance Tests\\2025_Performance_CyclingLacevBOA_Specialized\\Wahoo\\SteadySprintTrials\\0_CompiledPowerData.csv')
powerDat <- left_join(powerDat,anthroDat, by = 'Subject')
powerDat$Power_sprint = powerDat$Power_sprint/powerDat$Mass

#Pressure Dat during Cycling 
pressDat <- read.csv('C:\\Users\\eric.honert\\Boa Technology Inc\\PFL Team - General\\Testing Segments\\Cycling Performance Tests\\2025_Performance_CyclingLacevBOA_Specialized\\Xsensor\\0_CompiledResults.csv') 
pressDat <- subset(pressDat, pressDat$Movement == 'Steady')

pressDat <-pressDat %>% 
  mutate(Config = replace(Config, Config == 'DD', 'BOA'))

staticDat <- read.csv('C:\\Users\\eric.honert\\Boa Technology Inc\\PFL Team - General\\Testing Segments\\Cycling Performance Tests\\2025_Performance_CyclingLacevBOA_Specialized\\Xsensor\\Static\\0_CompiledResults_Static.csv')
staticDat <-staticDat %>% 
  mutate(Config = replace(Config, Config == 'DD', 'BOA'))

# Metabolic Data
metDat <- read.csv('C:\\Users\\eric.honert\\Boa Technology Inc\\PFL Team - General\\Testing Segments\\Cycling Performance Tests\\2025_Performance_CyclingLacevBOA_Specialized\\Metabolics\\0_MetabolicOutcomes.csv')

metDat <-metDat %>% 
  mutate(Config = replace(Config, Config == 'DD', 'BOA'))


baseline <- 'Lace' # baseline configuration

otherConfigs <- c('BOA') # other configurations tested against base
allConfigs <- c(baseline, otherConfigs) 


powerDat <- as_tibble(powerDat) # creating the data frame
powerDat$Config <- factor(powerDat$Config, allConfigs)

pressDat <- as_tibble(pressDat)
pressDat$Config <- factor(pressDat$Config, allConfigs)

staticDat <- as_tibble(staticDat)
staticDat$Config<- factor(staticDat$Config, allConfigs)

metDat <- as_tibble(metDat)
metDat$Config<- factor(metDat$Config, allConfigs)

qualDat$Config <- factor(qualDat$Config, allConfigs)


withinSubPlotAvg <- function(inputDF, colName, dir = 'lower', yLabel = NULL) {
  # Validate the `dir` input
  if(!dir %in% c('lower', 'higher')){
    stop("The 'dir' argument must be either 'lower' or 'higher'.")
  }
  # Calculate the mean for each Subject and Config, removing NA values
  meanDat <- inputDF %>%
    group_by(Subject, Config) %>%
    summarize(mean = mean(!! sym(colName), na.rm = TRUE), .groups = 'drop')
  # Determine the best configuration based on the direction
  if (dir == 'lower'){
    whichConfig <- meanDat %>%
      group_by(Subject) %>%
      reframe(BestConfig = Config[which.min(mean)])
  } else if (dir == 'higher') {
    whichConfig <- meanDat %>%
      group_by(Subject) %>%
      reframe(BestConfig = Config[which.max(mean)])
  }
  # Rename BestConfig to Config for merging
  whichConfig <- whichConfig %>%
    rename(Config = BestConfig)
  # Merge the best configuration back to the mean data
  mergedData <- merge(meanDat, whichConfig, by = c("Subject", "Config"))
  # Calculate overall mean for each Config, removing NA values
  overallMean <- meanDat %>%
    group_by(Config) %>%
    summarize(overallMean = mean(mean, na.rm = TRUE), .groups = 'drop')
  # Plotting with ggplot2
  plot <- ggplot() +
    geom_point(data = meanDat, mapping = aes(x = as.factor(Config), y = mean, group = Subject, color = 'Subject Means'), size = 3, alpha = 0.5) +
    geom_line(data = meanDat, mapping = aes(x = as.factor(Config), y = mean, group = Subject, color = 'Subject Means'), alpha = 0.5) +
    geom_point(data = overallMean, mapping = aes(x = as.factor(Config), y = overallMean, color = 'Overall Mean'), size = 4, shape = 17) +
    geom_line(data = overallMean, mapping = aes(x = as.factor(Config), y = overallMean, group = 1, color = 'Overall Mean'), linewidth = 1.5) +
    scale_color_manual(values = c('Subject Means' = 'grey', 'Overall Mean' = '#003C4C')) +
    xlab('Configuration') +
    theme(text = element_text(size = 16), legend.title = element_blank())
  # Set y-axis label
  if (!is.null(yLabel)) {
    plot <- plot + ylab(yLabel)
  } else {
    plot <- plot + ylab(paste0(colName))
  }
  print(plot)
}

extractVals <- function(dat, mod, configNames, baseConfig, var, dir) {
  
  Config = rep(NA, length(configNames))
  ProbImp = matrix(0, length(configNames))
  lowCI = matrix(0, length(configNames))
  highCI = matrix(0, length(configNames))
  
  for (i in 1:length(configNames)) {
    # This function takes the original dataframe (dat, same one entered into runmod), the Bayesian model from brms (runmod), 
    # the configuration Name, and the variable you are testing. It returns:
    # [1] the probabality the variable was better in the test config vs. the baseline config
    # [3] the lower bound of the bayesian 95% posterior interval (as percent change from baseline) 
    # [4] the upper bound of the bayesian 95% posterior interval (as percent change from baseline)
    #i = 1
    
    configName = configNames[i]
    configColName <- paste('b_Config', configName, sep = "")
    posterior <- posterior_samples(mod)
    
    if (dir == 'lower'){
      prob <- sum(posterior[,configColName] < 0) / length(posterior[,configColName])
      
    } else if (dir == 'higher') {
      
      prob <- sum(posterior[,configColName] > 0) / length(posterior[,configColName])
    }
    
    ci <- posterior_interval(mod, prob = 0.80)
    ciLow <- ci[configColName,1] 
    ciHigh <- ci[configColName,2]
    
    SDdat <- dat %>%
      group_by(Subject) %>%
      summarize(sd = sd(!! sym(var), na.rm = TRUE), mean = mean(!! sym(var), na.rm = TRUE))
    
    meanSD = mean(SDdat$sd , na.rm = TRUE)
    mean = mean(SDdat$mean, na.rm = TRUE)
    ci_LowPct <- meanSD*ciLow/mean*100
    ci_HighPct <- meanSD*ciHigh/mean*100
    
    output = list('Config:', configName, 'Probability of Improvement:', prob, 'Worse end of CI:', ci_LowPct, 'Best end of CI:', ci_HighPct)
    Config[i] = configName
    ProbImp[i] = prob
    lowCI[i] = ci_LowPct
    highCI[i] = ci_HighPct
  }
  ProbImp = round(ProbImp*100)
  lowCI = round(lowCI, 1)
  highCI = round(highCI,1)
  output = cbind(Config, ProbImp, lowCI, highCI)
  
  colnames(output) = c('Config', 'Probability of Improvement', 'Low end of CI', 'High end of CI')
  
  sentences = rep(NA, nrow(output))
  
  for (i in 1:nrow(output)){
    if (as.numeric(output[i,2]) >= 90){
      sentences[i] <- paste0('We have meaningful confidence that ',output[i,1], ' outperformed ', baseConfig, ' (',output[i,2], '%)', '\n', '\t', '- Estimated difference: ',output[i,3],' to ',output[i,4],'%' )
    } else if (as.numeric(output[i,2]) >= 80) {      
      sentences[i] <- paste('We have moderate confidence that',output[i,1], 'outperformed', baseConfig, '(',output[i,2], '%)','\n', '\t', '- Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 70){
      sentences[i] <- paste('We have minimal confidence that',output[i,1], 'outperformed', baseConfig, '(',output[i,2], '%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 30){
      sentences[i] <- paste('There were inconsistent differences between',output[i,1],'and',baseConfig,'(',output[i,2],'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 20){
      sentences[i] <- paste('We have minimal confidence that',output[i,1],'performed worse than',baseConfig,'(',(100 - as.numeric(output[i,2])),'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 10){
      sentences[i] <- paste('We have moderate confidence that',output[i,1],'performed worse than',baseConfig,'(',(100 - as.numeric(output[i,2])),'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else {
      sentences[i] <- paste('We have meaningful confidence that',output[i,1],'performed worse than',baseConfig,'(',(100 - as.numeric(output[i,2])),'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    }
  }
  
  writeLines(sentences)
  return()
}

# qual average plot
withinSubQualAvg <- function(inputDF) {
  
  # direction can be 'lower' or higher'. It is the direction of change that is better. 
  # For example, for contact time lower is better. so we put 'lower'. for jump height, higher is better, so we put higher. 
  # Calculate the mean for each Subject and Config, removing NA values
  meanDat <- inputDF %>%
    group_by(Subject, Config) %>%
    summarize(mean = mean(OverallFit, na.rm = TRUE), .groups = 'drop')
  
  
  whichConfig <- inputDF %>%
    group_by(Subject) %>%
    summarize(
      BestConfig = Config[which.max(OverallFit)]
    )
  
  whichConfig <- whichConfig %>%
    rename(Config = BestConfig)
  
  mergeDat <- merge(meanDat, whichConfig)
  
  overallMean <- meanDat %>%
    group_by(Config) %>%
    summarize(overallMean = mean(mean, na.rm = TRUE), .groups = 'drop')
  # Plotting with ggplot2
  plot <- ggplot() +
    geom_point(data = meanDat, mapping = aes(x = as.factor(Config), y = mean, group = Subject, color = 'Subject Means'), size = 3, alpha = 0.5) +
    geom_line(data = meanDat, mapping = aes(x = as.factor(Config), y = mean, group = Subject, color = 'Subject Means'), alpha = 0.5) +
    geom_point(data = overallMean, mapping = aes(x = as.factor(Config), y = overallMean, color = 'Overall Mean'), size = 4, shape = 17) +
    geom_line(data = overallMean, mapping = aes(x = as.factor(Config), y = overallMean, group = 1, color = 'Overall Mean'), linewidth = 1.5) +
    scale_color_manual(values = c('Subject Means' = 'grey', 'Overall Mean' = '#003C4C')) +
    xlab('Configuration') + ylab('Rating') +
    theme(text = element_text(size = 16), legend.title = element_blank()) 
    
  
  print(plot)
  
}

EffectSizeLM <- function(df, inputmodel) {
  myformula <- as.formula(paste0(inputmodel))
  full.mod = lmer(myformula, data = df, REML = TRUE, na.action = "na.omit")
  conditions.emm <- emmeans(full.mod, "Config", lmer.df = "satterthwaite")
  efsi_sum = summary(eff_size(conditions.emm, sigma = sigma(full.mod), edf = Inf))
  
  for (ii in 1:(length(unique(df$Config))-1)){
    print(paste('effect size for:', efsi_sum$contrast[ii], ' is ', round(efsi_sum$effect.size[ii],3)))
  }

return()
}

###############################
```

# Summary of Findings

(Did we achieve the goal of the study?)

# Next Steps

-   

# Recommendations

-   

# Key Benefit Performance

|                             | Base | Config1 | Config2 |
|-----------------------------|------|---------|---------|
| Power Transfer              | 50   |         |         |
| Energy Efficiency           | 50   |         |         |
| Stability & Control         | 50   |         |         |
| Quantitative Fit            | 50   |         |         |
| Overall Performance Ranking | 50   |         |         |

# Additional Benefit Performance

|                     | Base | Config1 | Config2 |
|---------------------|------|---------|---------|
| Qualitative Ranking | 90   |         |         |

# **Qualitative**

```{r}
#| echo: false
#| layout-ncol: 2
#| tbl-column: page-right
#| fig-column: page-left
#| warning: false
#| fig-height: 7
#| fig-width: 4

qualDatplot <- pivot_longer(qualDat, cols = Forefoot:Heel, names_to = 'Location', values_to = 'Rating')

qualDatplot$Location <- factor(qualDatplot$Location, c('Forefoot', 'Midfoot', 'Heel')) 


a <- withinSubQualAvg(qualDat)

b <- ggplot(qualDatplot, mapping = aes(x = Rating, fill = Config)) + 
  geom_histogram(position = 'dodge', binwidth = 1) + facet_wrap(~Location) + scale_fill_manual(values=c("#999999", "#00966C", "#ECE81A","#DC582A","#CAF0E4")) +
  ylab('Responses') + theme(text=element_text(size=12)) + geom_vline(xintercept = 5, linewidth = 1) 


figs <- ggarrange(a, b, ncol = 1, nrow = 2)
figs

qualDat %>%
  pivot_longer(cols = OverallFit:Heel, 
               names_to = "Location", values_to = "Rating") %>%
  group_by(Location, Config) %>%
  summarize(
    Avg = median(Rating, na.rm = TRUE)
  ) %>%
  gt()
```

## **Dial Torque**

```{r}
#| echo: false
#| warning: false
qualDat %>%
  group_by(Config)%>%
  summarize(
    R_Torque_Prox = mean(R_DialTorque1, na.rm = TRUE),
    R_Torque_Dist = mean(R_DialTorque2, na.rm = TRUE),
    L_Torque_Prox = mean(L_DialTorque1, na.rm = TRUE),
    L_Torque_Dist = mean(L_DialTorque2, na.rm = TRUE)
  )%>%
  gt()

# withinSubPlotAvg(qualDat, colName ='R_DialTorque1', dir = 'higher')  + ylab('Instep Dial - Torque [N-cm]')

```

# Energy Efficiency

## **Energy Expenditure - Lower is Better**

```{r}
#| echo: false
#| warning: false
#| include: false 
################
###############################################
 

###### Energy Efficiency

EEDat <- metDat %>%
  group_by(Subject) %>%
  mutate(z_score = scale(EE)) %>%
  group_by(Config)

ggplot(data = EEDat, aes(x = EE, fill = Config)) + geom_histogram() + facet_wrap(~Subject) 


EEDatMod <- brm(data = EEDat, # Bayes model
              family = gaussian,
              z_score ~ Config + Order + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .999, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 

withinSubPlotAvg(EEDat, colName = 'EE', dir = 'lower', yLabel = 'Energy Expenditure (W/kg)')  
extractVals(EEDat, EEDatMod, otherConfigs, baseline, 'EE', 'lower') 

EffectSizeLM(EEDat,'EE ~ Config + (Config|Subject)')
```

# Power Transfer

## **Sprint Power - Higher is Better**

```{r}
#| echo: false
#| warning: false
#| include: false 
################
###############################################
 

###### Peak Sprinting Power

sprintDat <- powerDat %>%
  group_by(Subject) %>%
  mutate(z_score = scale(Power_sprint)) %>%
  group_by(Config)

ggplot(data = sprintDat, aes(x = Power_sprint, fill = Config)) + geom_histogram() + facet_wrap(~Subject) 


sprintDatMod <- brm(data = sprintDat, # Bayes model
              family = gaussian,
              z_score ~ Config + Order + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .999, max_treedepth = 20),
              seed = 190831)


```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 

withinSubPlotAvg(sprintDat, colName = 'Power_sprint', dir = 'higher', yLabel = 'Sprint Power (W/kg)')  
extractVals(sprintDat, sprintDatMod, otherConfigs, baseline, 'Power_sprint', 'higher') 
```

# **Quantitative Fit**

## Peak Toe Pressure - Lower is Better

```{r}
#| echo: false
#| warning: false
#| include: false 

# Plantar Max Toe Pressure

toemaxDat<- pressDat %>% 
  group_by(Subject) %>%
  mutate(z_score = scale(maxmaxToes)) %>% 
  group_by(Config)

ggplot(data = toemaxDat, aes(x = maxmaxToes, fill = Config)) + geom_histogram() + facet_wrap(~Subject) 

toemaxMod <- brm(data = toemaxDat, # Bayes model
              family = gaussian,
              z_score ~ Config + Order + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 

withinSubPlotAvg(toemaxDat, colName = 'maxmaxToes', dir = 'lower', yLabel = 'Max Toe Pressure (kPa)')

extractVals(toemaxDat, toemaxMod, otherConfigs, baseline, 'maxmaxToes', 'lower')
```

## **Heel Contact Area - Higher is Better**

```{r}
#| echo: false
#| warning: false
#| include: false 
heelConDat <- pressDat %>% 
  group_by(Subject) %>%
  mutate(z_score = scale(heelArea_Up)) %>% 
  group_by(Config)

ggplot(data = heelConDat, aes(x = heelArea_Up, fill = Config)) + geom_histogram() + facet_wrap(~Subject) 

heelConMod <- brm(data = heelConDat, # Bayes model
              family = gaussian,
              z_score ~ Config + Order + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2  

withinSubPlotAvg(heelConDat, colName = 'heelArea_Up', dir = 'higher', yLabel = 'Heel Contact Area (%)')

extractVals(heelConDat, heelConMod, otherConfigs, baseline, 'heelArea_Up', 'higher')
```

## **Dorsal Pressure Metrics**

**Dorsal Pressure Variation**

```{r}
#| echo: false
#| warning: false
#| include: false 
################

###############################################
# SD Dorsal Pressure

covDorPress <- staticDat %>% 
  # group_by(Subject) %>% # Note this is commented out because only 2 conditions were used in this study
  mutate(z_score = scale(covDorsalPressure)) %>% 
  group_by(Subject, Config) # Note this is different because only 2 conditions were used in this study

# Note: these models are updated for non-zscored data
covDorPressMod <- brm(data = covDorPress, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + 1 | Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(1, 2), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 
withinSubPlotAvg(covDorPress , colName = 'covDorsalPressure', dir = 'lower', yLabel = 'Dorsal Pressure Variation')  

extractVals(covDorPress, covDorPressMod, otherConfigs, baseline, 'covDorsalPressure', 'lower') 
```

**Peak Dorsal Pressure**

```{r}
#| echo: false
#| warning: false
#| include: false 
################

###############################################
# Average Dorsal Pressure

peakDorPress <- staticDat %>% 
  # group_by(Subject) %>% # Note this is commented out because only 2 conditions were used in this study
  mutate(z_score = scale(maxDorsalPressure)) %>% 
  group_by(Subject, Config) # Note this is different because only 2 conditions were used in this study

# Note: these models are updated for non-zscored data
peakDorPressMod <- brm(data = peakDorPress, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + 1 | Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(1, 2), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 
withinSubPlotAvg(peakDorPress , colName = 'maxDorsalPressure', dir = 'lower', yLabel = 'Peak Dorsal Pressure (kPa)')  

extractVals(peakDorPress, peakDorPressMod, otherConfigs, baseline, 'maxDorsalPressure', 'lower') 
```

**Average Dorsal Pressure**

```{r}
#| echo: false
#| warning: false
#| include: false 
################

###############################################
# Averager Dorsal Pressure

avgDorPress <- staticDat %>% 
  # group_by(Subject) %>% # Note this is commented out because only 2 conditions were used in this study
  mutate(z_score = scale(meanDorsalPressure)) %>% 
  group_by(Subject, Config) # Note this is different because only 2 conditions were used in this study

# Note: these models are updated for non-zscored data
avgDorPressMod <- brm(data = avgDorPress, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + 1 | Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(1, 2), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 
withinSubPlotAvg(avgDorPress , colName = 'meanDorsalPressure', dir = 'higher', yLabel = 'Avg Dorsal Pressure (kPa)')  

extractVals(avgDorPress, avgDorPressMod, otherConfigs, baseline, 'meanDorsalPressure', 'higher') 
```

**Average Instep Pressure**

```{r}
#| echo: false
#| warning: false
#| include: false 
################

###############################################
# Dorsal Instep pressure

staticDat_instPres <- staticDat %>% 
  group_by(Subject) %>% # Note this is commented out because only 2 conditions were used in this study
  mutate(z_score = scale(instepDorsalPressure)) %>% 
  group_by(Config) # Note this is different because only 2 conditions were used in this study


# Note: these models are updated for non-zscored data
instDorsalMod <- brm(data = staticDat_instPres, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + 1 | Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(1, 2), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 
withinSubPlotAvg(staticDat_instPres , colName = 'instepDorsalPressure', dir = 'higher', yLabel = 'Avg Instep Pressure (kPa)')  

extractVals(staticDat_instPres, instDorsalMod, otherConfigs, baseline, 'instepDorsalPressure', 'higher') 
```

**Average Midfoot Pressure**

```{r}
#| echo: false
#| warning: false
#| include: false 
################

# Dorsal Midfoot ave pressure 
mfPDat<- staticDat %>% 
  # group_by(Subject) %>% # Note this is commented out because only 2 conditions were used in this study
  mutate(z_score = scale(mfDorsalPressure)) %>% 
  group_by(Subject, Config) # Note this is different because only 2 conditions were used in this study


mfPMod <- brm(data = mfPDat, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + 1| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 

withinSubPlotAvg(mfPDat, colName = 'mfDorsalPressure', dir = 'higher', 'Avg Midfoot Pressure (kPa)') 

extractVals(mfPDat, mfPMod, otherConfigs, baseline, 'mfDorsalPressure', 'higher') 

```

**Average Forefoot Pressure**

```{r}
#| echo: false
#| warning: false
#| include: false 
################

# Dorsal Forefoot ave pressure 
ffPDat<- staticDat %>% 
  group_by(Subject) %>% # Note this is commented out because only 2 conditions were used in this study
  mutate(z_score = scale(ffDorsalPressure)) %>% 
  group_by(Config) # Note this is different because only 2 conditions were used in this study


ffPMod <- brm(data = ffPDat, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + 1| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)

```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 

withinSubPlotAvg(ffPDat, colName = 'ffDorsalPressure', dir = 'higher', yLabel = 'Avg Forefoot Pressure (kPa)')

extractVals(ffPDat, ffPMod, otherConfigs, baseline, 'ffDorsalPressure', 'higher') 
```
