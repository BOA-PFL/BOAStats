---
title: "PFL DATA REPORT"
format: 
  docx:
    reference-doc: 'C:/Users/eric.honert/Boa Technology Inc/PFL Team - General/Testing Segments/Report_Template.docx'
editor: visual
editor_options: 
  chunk_output_type: console
execute:
  error: True
  warning: False
---

# CONFIDENTAL CONTENT FOR BOA EMPLOYEES ONLY. PLEASE CONTACT PFL DIRECTLY WITH ANY QUESTIONS.

+--------------------+------------------------------------------------+
| Test Name          | 2025_Mechanistic_WomensPanelStiffnessII_Adidas |
+====================+================================================+
| **Benefit:**       | Agility & Speed                                |
+--------------------+------------------------------------------------+
| **Date:**          | 4/2023                                         |
+--------------------+------------------------------------------------+
| **Test Type:**     | Performance                                    |
+--------------------+------------------------------------------------+
| **Configurations** | Baseline: SD (Single Dial)                     |
|                    |                                                |
|                    | Test configurations:                           |
|                    |                                                |
|                    | -   SDHL (Single Dial Heel-Lock)               |
|                    |                                                |
|                    | -   DDHL (Dual Dial Heel-Lock)                 |
+--------------------+------------------------------------------------+

## Purpose & Background

-   Previous cycling performance tests (Cycling_DDRoad_Performance_Feb22) showed improvements due to a heel lock guide providing immediate lace pull toward the heel cut.

-   The purpose of this test was to evaluate how a heel lock guide affects agility and speed performance in a single dial and dual dial configuration.

## Hypothesis

H1: The heel lock will improve heel hold and the dual dial heel lock will provide the best fit. Heel hold will be measured as contact area between the heel and the midsole during running. Forefoot hold will be measured as pressure and contact area between the forefoot and midsole during running.

H2: Improved fit will result in better agility, ie. [reduced contact time.]{.underline}

H1.a: Reduced contact time will be achieved through increased propulsive force (i.e. in the direction of movement), and increased ankle force production in the direction of movement

## Methods

+------------------+---------------------+-------------------------------+------------------------------+
| Subjects         | Movements           | Equipment                     | Measurements                 |
+==================+=====================+===============================+==============================+
| 11 Male Athletes | Treadmill Running   | Pressure insoles              | Fit:                         |
|                  |                     |                               |                              |
|                  |                     |                               | -   Heel contact area        |
|                  |                     |                               |                              |
|                  |                     |                               | -   Peak Toe Pressure        |
+------------------+---------------------+-------------------------------+------------------------------+
|                  | Vertical CMJ        | Force plates &                | Power Transfer:              |
|                  |                     |                               |                              |
|                  |                     | Motion Capture                | -   Time to change direction |
|                  |                     |                               |                              |
|                  |                     |                               | -   Peak Power               |
|                  |                     |                               |                              |
|                  |                     |                               | -   Peak Ankle Force         |
|                  |                     |                               |                              |
|                  |                     |                               | Stability & Control          |
|                  |                     |                               |                              |
|                  |                     |                               | -   Peak Ankle Velocity      |
|                  |                     |                               |                              |
|                  |                     |                               | -   Peak Knee Frontal ROM    |
+------------------+---------------------+-------------------------------+------------------------------+
|                  | Lateral Skater Jump | Force plates & Motion Capture | Power Transfer               |
|                  |                     |                               |                              |
|                  |                     |                               | -   Time to change direction |
|                  |                     |                               |                              |
|                  |                     |                               | -   Peak Power               |
|                  |                     |                               |                              |
|                  |                     |                               | -   Peak Ankle Force         |
+------------------+---------------------+-------------------------------+------------------------------+

## Configurations

| Baseline | Config1 | Config2 |
|----------|---------|---------|
|          |         |         |

```{r}
#| echo: false
#| warning: false
#| include: false


library(readxl)
library(tidyverse)
library(tm)
library(SnowballC)
library(RColorBrewer)
library(wordcloud)
library(readxl)
library(brms)
library(patchwork)
library(tidyr)
library(fmsb)
library(gt)
rm(list=ls())
```

```{r}
#| echo: false
#| warning: false
#| include: false

# Load in overground agility data
dat <- read.csv('C:\\Users\\milena.singletary\\OneDrive - BOA Technology Inc\\General - PFL Team\\Testing Segments\\AgilityPerformanceData\\2025_Mechanistic_WomensPanelStiffnessII_Adidas\\Overground\\0_CompiledAgilityData.csv')

#Load in Compiled Qualitative Sheet
# qualDat <- read_xlsx(file.choose())
qualDat <- read_xlsx('C:\\Users\\milena.singletary\\OneDrive - BOA Technology Inc\\General - PFL Team\\Testing Segments\\AgilityPerformanceData\\2025_Mechanistic_WomensPanelStiffnessII_Adidas\\2025_Mech_WomensPanelStiffnessII_Adidas.xlsx')

#Load in Treadmill data
treadmill <- read.csv('C:\\Users\\milena.singletary\\OneDrive - BOA Technology Inc\\General - PFL Team\\Testing Segments\\AgilityPerformanceData\\2025_Mechanistic_WomensPanelStiffnessII_Adidas\\Treadmill\\TreadmillOutcomes.csv')


#Load in Pressure data from running
pressure <- read.csv('C:\\Users\\milena.singletary\\OneDrive - BOA Technology Inc\\General - PFL Team\\Testing Segments\\AgilityPerformanceData\\2025_Mechanistic_WomensPanelStiffnessII_Adidas\\Xsensor\\cropped\\0_CompiledResults.csv')

#Load in Static pressure data
static <- read.csv('C:\\Users\\milena.singletary\\OneDrive - BOA Technology Inc\\General - PFL Team\\Testing Segments\\AgilityPerformanceData\\2025_Mechanistic_WomensPanelStiffnessII_Adidas\\Xsensor\\static\\0_CompiledResults_Static.csv')


baseline <- 'MSE' # baseline configuration

otherConfigs <- c('MSI', 'HSE', 'HSI') # other configurations tested against base
allConfigs <- c(baseline, otherConfigs)
qualDat$Config <- factor(qualDat$Config, allConfigs)
dat <- as_tibble(dat) # creating the data frame
dat$Config <- factor(dat$Config, allConfigs)

treadmill <- as_tibble(treadmill)
treadmill$Config <- factor(treadmill$Config, allConfigs)

Press <- as_tibble(pressure)
Press$Config <- factor(Press$Config, allConfigs)

static <- as_tibble(static)
static$Config <- factor(static$Config, allConfigs)



## Within Sub Plot Averages
withinSubPlotAvg <- function(inputDF, colName, dir = 'lower', yLabel = NULL) {

  # Validate the `dir` input
  if(!dir %in% c('lower', 'higher')){
    stop("The 'dir' argument must be either 'lower' or 'higher'.")
  }
  # Calculate the mean for each Subject and Config, removing NA values
  meanDat <- inputDF %>%
    group_by(Subject, Config) %>%
    summarize(mean = mean(!! sym(colName), na.rm = TRUE), .groups = 'drop')
  cat("meanDat:\n")
  # print(meanDat)
  # Determine the best configuration based on the direction
  if (dir == 'lower'){
    whichConfig <- meanDat %>%
      group_by(Subject) %>%
      reframe(BestConfig = Config[which.min(mean)])
  } else if (dir == 'higher') {
    whichConfig <- meanDat %>%
      group_by(Subject) %>%
      reframe(BestConfig = Config[which.max(mean)])
  } 

  cat("whichConfig:\n")
  # print(whichConfig)
  
  # Rename BestConfig to Config for merging
  whichConfig <- whichConfig %>%
    rename(Config = BestConfig)
  cat("whichConfig after rename:\n")
  # print(whichConfig)

  # Calculate overall mean for each Config, removing NA values
  overallMean <- meanDat %>%
    group_by(Config) %>%
    summarize(overallMean = mean(mean, na.rm = TRUE), overallSD = sd(mean, na.rm = TRUE), .groups = 'drop') %>%
    mutate(overallMean = format(overallMean, nsmall = 2),
           overallSD = format(overallSD, nsmall = 2))
  cat("overallMean:\n")
  # print(overallMean)
     
  # Plotting with ggplot2


# Ensure mean and overallMean are numeric
meanDat$mean <- as.numeric(meanDat$mean)
overallMean$overallMean <- as.numeric(overallMean$overallMean)

plot <- ggplot() +
  geom_point(data = meanDat, mapping = aes(x = as.factor(Config), y = mean, group = Subject), color = 'grey', size = 3, alpha = 0.5) +
  geom_line(data = meanDat, mapping = aes(x = as.factor(Config), y = mean, group = Subject), color = 'grey', alpha = 0.5) +
  geom_line(data = overallMean, mapping = aes(x = as.factor(Config), y = overallMean, group = 1), color = '#003C4C', linewidth = 1.5) + 
  geom_point(data = overallMean, mapping = aes(x = as.factor(Config), y = overallMean), color = '#003C4C', size = 6, shape = 18) +
  xlab('Configuration') + 
  theme(text = element_text(size = 16)) 

# Set y-axis label
if (!is.null(yLabel)) {
  plot <- plot + ylab(yLabel)
} else {
  plot <- plot + ylab(paste0(colName))
}

print(plot)
}


extractVals <- function(dat, mod, configNames, baseConfig, var, dir) {
  
  Config = rep(NA, length(configNames))
  ProbImp = matrix(0, length(configNames))
  lowCI = matrix(0, length(configNames))
  highCI = matrix(0, length(configNames))
  
  for (i in 1:length(configNames)) {
    # This function takes the original dataframe (dat, same one entered into runmod), the Bayesian model from brms (runmod), 
    # the configuration Name, and the variable you are testing. It returns:
    # [1] the probabality the variable was better in the test config vs. the baseline config
    # [3] the lower bound of the bayesian 95% posterior interval (as percent change from baseline) 
    # [4] the upper bound of the bayesian 95% posterior interval (as percent change from baseline)
    #i = 1
    
    configName = configNames[i]
    configColName <- paste('b_Config', configName, sep = "")
    posterior <- posterior_samples(mod)
    
    if (dir == 'lower'){
      prob <- sum(posterior[,configColName] < 0) / length(posterior[,configColName])
      
    } else if (dir == 'higher') {
      
      prob <- sum(posterior[,configColName] > 0) / length(posterior[,configColName])
    }
    
    ci <- posterior_interval(mod, prob = 0.80)
    ciLow <- ci[configColName,1] 
    ciHigh <- ci[configColName,2]
    
    SDdat <- dat %>%
      group_by(Subject) %>%
      summarize(sd = sd(!! sym(var), na.rm = TRUE), mean = mean(!! sym(var), na.rm = TRUE))
    
    meanSD = mean(SDdat$sd)
    mean = mean(SDdat$mean)
    ci_LowPct <- meanSD*ciLow/mean*100
    ci_HighPct <- meanSD*ciHigh/mean*100
    
    output = list('Config:', configName, 'Probability of Improvement:', prob, 'Worse end of CI:', ci_LowPct, 'Best end of CI:', ci_HighPct)
    Config[i] = configName
    ProbImp[i] = prob
    lowCI[i] = ci_LowPct
    highCI[i] = ci_HighPct
  }
  ProbImp = round(ProbImp*100)
  lowCI = round(lowCI, 1)
  highCI = round(highCI,1)
  output = cbind(Config, ProbImp, lowCI, highCI)
  
  colnames(output) = c('Config', 'Probability of Improvement', 'Low end of CI', 'High end of CI')
  
  sentences = rep(NA, nrow(output))
  
  for (i in 1:nrow(output)){
    if (as.numeric(output[i,2]) >= 90){
      sentences[i] <- paste0('We have meaningful confidence that ',output[i,1], ' outperformed ', baseConfig, ' (',output[i,2], '%)', '\n', '\t', '- Estimated difference: ',output[i,3],' to ',output[i,4],'%' )
    } else if (as.numeric(output[i,2]) >= 80) {      
      sentences[i] <- paste('We have moderate confidence that',output[i,1], 'outperformed', baseConfig, '(',output[i,2], '%)','\n', '\t', '- Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 70){
      sentences[i] <- paste('We have minimal confidence that',output[i,1], 'outperformed', baseConfig, '(',output[i,2], '%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 30){
      sentences[i] <- paste('There were inconsistent differences between',output[i,1],'and',baseConfig,'(',output[i,2],'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 20){
      sentences[i] <- paste('We have minimal confidence that',output[i,1],'performed worse than',baseConfig,'(',(100 - as.numeric(output[i,2])),'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else if (as.numeric(output[i,2]) >= 10){
      sentences[i] <- paste('We have moderate confidence that',output[i,1],'performed worse than',baseConfig,'(',(100 - as.numeric(output[i,2])),'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    } else {
      sentences[i] <- paste('We have meaningful confidence that',output[i,1],'performed worse than',baseConfig,'(',(100 - as.numeric(output[i,2])),'%)','\n', '\t', 'Estimated difference:',output[i,3],'to',output[i,4],'%')
    }
  }
  
  writeLines(sentences)
  return()
}


###############################
```

## Next Steps

-   

## Recommendations

-   

## Performance Rankings

|                             | Base | Config1 | Config2 |
|-----------------------------|------|---------|---------|
| Qualitative Ranking         | 90   |         |         |
| Power Transfer              | 50   |         |         |
| Energy Efficiency           | 50   |         |         |
| Stability & Control         | 50   |         |         |
| Quantitative Fit            | 50   |         |         |
| Overall Performance Ranking | 50   |         |         |

## Radar Plots

| Base | Config1 | Config2 |
|------|---------|---------|
|      |         |         |

## **Qualitative**

```{r}
#| echo: false
#| warning: false
#| include: false


qualDat %>%
  pivot_longer(cols = OverallFit:Heel, 
               names_to = "Location", values_to = "Rating") %>%
  group_by(Location, Config) %>%
  summarize(
    avg = mean(Rating, na.rm = TRUE),
    medAvg = median(Rating, na.rm = TRUE)
  ) %>%
  gt()


#Defining the rating for the location 
#Density plots for fit ratings of shoe locations
qualDat <- pivot_longer(qualDat, cols = Forefoot:Heel, names_to = 'Location', values_to = 'Rating')

FF <- qualDat %>% 
  filter(Location=="Forefoot")


qualDat$Location <- factor(qualDat$Location, c('Forefoot', 'Midfoot', 'Heel')) 

```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 


withinSubQualPlot(qualDat)
ggplot(qualDat, mapping = aes(x = Rating, fill = Config)) + 
  geom_histogram(position = 'dodge', binwidth = 1) + facet_wrap(~Location) + scale_fill_manual(values=c("#999999", "#00966C", "#ECE81A","#DC582A","#CAF0E4")) +
  ylab('Responses') + theme(text=element_text(size=20)) + geom_vline(xintercept = 5, linewidth = 1)
```

```{r}
#| echo: false
#| warning: false
#| include: false


# qual average plot
withinSubQualAvg <- function(inputDF) {
  
  # direction can be 'lower' or higher'. It is the direction of change that is better. 
  # For example, for contact time lower is better. so we put 'lower'. for jump height, higher is better, so we put higher. 
  # Calculate the mean for each Subject and Config, removing NA values
  meanDat <- inputDF %>%
    group_by(Subject, Config) %>%
    summarize(mean = mean(OverallFit, na.rm = TRUE), .groups = 'drop')
  
  
  whichConfig <- inputDF %>%
    group_by(Subject) %>%
    summarize(
      BestConfig = Config[which.max(OverallFit)]
    )
  
  whichConfig <- whichConfig %>%
    rename(Config = BestConfig)
  
  mergeDat <- merge(meanDat, whichConfig)
  
  overallMean <- meanDat %>%
    group_by(Config) %>%
    summarize(overallMean = mean(mean, na.rm = TRUE), .groups = 'drop')
  # Plotting with ggplot2
  plot <- ggplot() +
    geom_point(data = meanDat, mapping = aes(x = as.factor(Config), y = mean, group = Subject, color = 'Subject Means'), size = 3, alpha = 0.5) +
    geom_line(data = meanDat, mapping = aes(x = as.factor(Config), y = mean, group = Subject, color = 'Subject Means'), alpha = 0.5) +
    geom_point(data = overallMean, mapping = aes(x = as.factor(Config), y = overallMean, color = 'Overall Mean'), size = 4, shape = 17) +
    geom_line(data = overallMean, mapping = aes(x = as.factor(Config), y = overallMean, group = 1, color = 'Overall Mean'), linewidth = 1.5) +
    scale_color_manual(values = c('Subject Means' = 'grey', 'Overall Mean' = '#003C4C')) +
    xlab('Configuration') + ylab('Rating') +
    theme(text = element_text(size = 16), legend.title = element_blank()) 
    
  
  print(plot)
  
}

withinSubQualAvg(qualDat)
```

**Dial Torque**

```{r}
#| echo: false
#| warning: false
#| include: false


qualDat %>%
  group_by(Config)%>%
  summarize(
    R_Torque_Prox = mean(R_DialTorque1, na.rm = TRUE),
    R_Torque_Dist = mean(R_DialTorque2, na.rm = TRUE),
    L_Torque_Prox = mean(L_DialTorque1, na.rm = TRUE),
    L_Torque_Dist = mean(L_DialTorque2, na.rm = TRUE)
  )%>%
  gt()

ggplot(qualDat, aes(x=Config, y = L_DialTorque1, color = Config, group= Subject)) + 
  geom_point(size = 4)+ 
  geom_line(aes(color=Config))+
  # facet_wrap(~Subject)+
  scale_color_manual(values=c("#000000","#00966C", "#ECE81A","#DC582A","#CAF0E4"))+ 
  theme(text = element_text(size = 16))+ 
  ylab('Proximal (instep) Dial - Torque [N-cm]')+ 
  xlab('Config')+
  ggtitle('Left Foot')




torqueDat <- qualDat %>%
  group_by(Subject) %>%
  mutate(z_score = scale(R_DialTorque1)) %>%
  group_by(Config)


torqueMod <- brm(data = torqueDat, # Bayes model
              family = gaussian,
              z_score ~  Config + (1  | Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas) 
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)


extractVals(torqueDat , torqueMod, otherConfigs, baseline, 'R_DialTorque1', 'higher')
```

## Power Transfer

### **Contact Time**

```{r}
#| echo: false
#| warning: false
#| include: false 

cmjDat <- subset(dat, dat$Movement == 'CMJ')


###### CMJ Contact Time

cmjDatCT <- cmjDat %>% 
  filter(CT > .1) %>% #remove values with impossible contact time
  filter(CT < 1.5) %>%
  group_by(Subject) %>%
  mutate(z_score = scale(CT)) %>% 
  group_by(Config)

cmjDatCT<- subset(cmjDatCT, cmjDatCT$z_score < 2) #removing outliers  
cmjDatCT<- subset(cmjDatCT, cmjDatCT$z_score > -2)

ggplot(data = cmjDatCT, aes(x = CT, fill = Config)) + geom_histogram() + facet_wrap(~Subject)


cmjCTMod <- brm(data = cmjDatCT, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)

```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 


withinSubPlotAvg(cmjDatCT, 'CT', 'lower', 'Contact Time (s)')


extractVals(cmjDatCT, cmjCTMod, otherConfigs, baseline,  'CT', dir = 'lower') 
```

### **Peak Force**

```{r}
#| echo: false
#| warning: false
#| include: false 

################
cmjDatPF <- cmjDat %>% 
  #filter(impulse_Z < 1000) %>%
  group_by(Subject) %>%
  mutate(z_score = scale(peakGRF_Z)) %>% 
  group_by(Config)

#cmjDat<- subset(cmjDat, cmjDat$z_score < 2) #removing outliers  
#cmjDat<- subset(cmjDat, cmjDat$z_score > -2)

ggplot(data = cmjDatPF, aes(x = peakGRF_Z, color = Config)) + geom_histogram() + facet_wrap(~Subject) 


cmjPFMod <- brm(data = cmjDatPF, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 


withinSubPlotAvg(cmjDatPF, 'peakGRF_Z', 'higher', 'Peak Propulsive Force (N)')


extractVals(cmjDatPF, cmjPFMod, otherConfigs, baseline, 'peakGRF_Z', 'higher')
```

### **Peak Plantarflexion Moment**

```{r}
#| echo: false
#| warning: false
#| include: false

################
cmjDatPP <- cmjDat %>% 
  filter(peakPFmom < 500) %>%
  group_by(Subject) %>%
  mutate(z_score = scale(peakPFmom)) %>% 
  group_by(Config)

#cmjDat<- subset(cmjDat, cmjDat$z_score < 2) #removing outliers  
#cmjDat<- subset(cmjDat, cmjDat$z_score > -2)

ggplot(data = cmjDatPP, aes(x = peakPFmom, color = Config)) + geom_histogram() + facet_wrap(~Subject) 


cmjPPMod <- brm(data = cmjDatPP, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)

```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 


withinSubPlotAvg(cmjDatPP, 'peakPFmom', 'higher', 'Peak Plantar Flexion Moment (Nm)')


extractVals(cmjDatPP, cmjPPMod, otherConfigs, baseline, 'peakPFmom', 'higher')
```

### Peak Power

```{r}
#| echo: false
#| warning: false
#| include: false


################
cmjDatPPow <- cmjDat %>% 
  filter(peakPFmom < 500) %>%
  group_by(Subject) %>%
  mutate(z_score = scale(peakPower)) %>% 
  group_by(Config)

cmjDatPPow<- subset(cmjDatPPow, cmjDatPPow$z_score < 2) #removing outliers  
cmjDatPPow<- subset(cmjDatPPow, cmjDatPPow$z_score > -2)

ggplot(data = cmjDatPPow, aes(x = peakPower, fill = Config)) + geom_histogram() + facet_wrap(~Subject)


cmjPowerMod <- brm(data = cmjDatPPow, # Bayes model
              family = gaussian,
              z_score ~ Config + Order + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 


withinSubPlotAvg(cmjDatPPow, 'peakPower', 'higher', 'Peak Power(W)')


extractVals(cmjDatPPow, cmjPowerMod, otherConfigs, baseline, 'peakPower', 'higher')

```

### **Skater Contact Time**

```{r}
#| echo: false
#| warning: false
#| include: false


skaterDat <- subset(dat, dat$Movement == 'Skater')


###### Skater Contact Time

skaterDatCT <- skaterDat %>% 
  #filter(CT > .1) %>% #remove values with impossible contact time
  #filter(CT < 1) %>%
  group_by(Subject) %>%
  mutate(z_score = scale(CT)) %>% 
  group_by(Config)

#skaterDat<- subset(skaterDat, skaterDat$z_score < 2) #removing outliers  
#skaterDat<- subset(skaterDat, skaterDat$z_score > -2)

ggplot(data = skaterDatCT, aes(x = CT, color = Config)) + geom_histogram() + facet_wrap(~Subject) ## Check for normalish distribution/outliers


skateCTMod <- brm(data = skaterDatCT, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)

```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 


withinSubPlotAvg(skaterDatCT, 'CT', 'lower', 'Contact Time (s)')


extractVals(skaterDatCT, skateCTMod, otherConfigs, baseline, 'CT', 'lower') 
```

### **Skater Propulsive Force**

```{r}
#| echo: false
#| warning: false
#| include: false


###### Skater peak propulsive force

skaterDatPF <- skaterDat %>% 
  group_by(Subject) %>%
  mutate(z_score = scale(peakGRF_X)) %>% 
  group_by(Config)

#skaterDat<- subset(skaterDat, dat$z_score < 2) #removing outliers  
#skaterDat<- subset(skaterDat, dat$z_score > -2)

ggplot(data = skaterDatPF, aes(x = peakGRF_X, color = Config)) + geom_histogram() + facet_wrap(~Subject)


skatePFMod <- brm(data = skaterDatPF, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)

```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 



withinSubPlotAvg(skaterDatPF, 'peakGRF_X', 'higher', 'Peak Propulsive Force (N)')

extractVals(skaterDatPF, skatePFMod, otherConfigs, baseline, 'peakGRF_X', 'higher')
```

### **Skater Power**

```{r}
#| echo: false
#| warning: false
#| include: false


skaterDatPow <- skaterDat %>% 
  group_by(Subject) %>%
  mutate(z_score = scale(peakPower)) %>% 
  group_by(Config)

skaterDatPow<- subset(skaterDatPow, skaterDatPow$z_score < 2) #removing outliers  
skaterDatPow<- subset(skaterDatPow, skaterDatPow$z_score > -2)

ggplot(data = skaterDatPow, aes(x = peakPower)) + geom_histogram() + facet_wrap(~Subject) 


skatePowMod <- brm(data = skaterDatPow, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)

```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2  



withinSubPlotAvg(skaterDatPow, 'peakPower', 'higher', 'Peak Power (W)')


extractVals(skaterDatPow, skatePowMod, otherConfigs, baseline, 'peakPower', 'higher') 

```

## Stability & Control

### Peak Knee Abduction Range of Motion

```{r}
#| echo: false
#| warning: false
#| include: false 

kneeAbdROM <- cmjDat %>% 
  group_by(Subject) %>%
  mutate(z_score = scale(kneeABDrom)) %>% 
  group_by(Config)

kneeAbdROM<- subset(kneeAbdROM, kneeAbdROM$z_score < 2) #removing outliers  
kneeAbdROM<- subset(kneeAbdROM, kneeAbdROM$z_score > -2)

ggplot(data = kneeAbdROM, aes(x = kneeABDrom)) + geom_histogram() + facet_wrap(~Subject) 


kneeAbdROMMod <- brm(data = kneeAbdROM, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)


```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2  


withinSubPlotAvg(kneeAbdROM, 'kneeABDrom', 'lower', 'Peak Knee Abduction Range of Motion (deg)')


extractVals(kneeAbdROM, kneeAbdROMMod, otherConfigs, baseline, 'kneeABDrom', 'lower') 

```

### Peak Ankle Eversion Velocity

```{r}
#| echo: false
#| warning: false
#| include: false 

ankEvVel <- cmjDat %>% 
  group_by(Subject) %>%
  mutate(z_score = scale(peakEVvel)) %>% 
  group_by(Config)

ankEvVel<- subset(ankEvVel, ankEvVel$z_score < 2) #removing outliers  
ankEvVel<- subset(ankEvVel, ankEvVel$z_score > -2)

ggplot(data = ankEvVel, aes(x = peakEVvel)) + geom_histogram() + facet_wrap(~Subject) 


ankEVvelMod <- brm(data = ankEvVel, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)


```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2  


withinSubPlotAvg(ankEvVel, 'peakEVvel', 'lower', 'Peak Ankle Eversion Velocity  (deg/s)')


extractVals(ankEvVel, ankEVvelMod, otherConfigs, baseline, 'peakEVvel', 'lower') 

```

## Energy Efficiency

### Positive Center of Mass Work - Running

```{r}
#| echo: false
#| warning: false
#| include: false 


COMp <- treadmill %>%
  group_by(Subject)%>%
  sample_n(75) %>% # select 75 random pts for faster model 
  mutate(z_score = scale(COMWork_pos)) %>% 
  group_by(Config)

COMp<- subset(COMp, COMp$z_score < 2) #removing outliers  
COMp<- subset(COMp, COMp$z_score > -2)


ggplot(data = COMp, aes(x = COMWork_pos, fill = Config)) + geom_histogram() + facet_wrap(~Subject)


COMwMod <- brm(data = COMp, # Bayes model
              family = gaussian,
              z_score ~ Config + Order + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)

```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2  



withinSubPlotAvg(COMp, 'COMWork_pos', 'lower', 'Positive Center of Mass Work (J)')


extractVals(COMp, COMwMod, otherConfigs, baseline, 'COMWork_pos', 'lower') 
```

### Negative Center of Mass Work - Running

```{r}
#| echo: false
#| warning: false
#| include: false 


COMn <- treadmill %>%
  group_by(Subject)%>%
  sample_n(75) %>% # select 75 random pts for faster model 
  mutate(z_score = scale(COMWork_neg)) %>% 
  group_by(Config)

COMn<- subset(COMn, COMn$z_score < 2) #removing outliers  
COMn<- subset(COMn, COMn$z_score > -2)

ggplot(data = COMn, aes(x = COMWork_neg, fill = Config)) + geom_histogram() + facet_wrap(~Subject)


NCOMwMod <- brm(data = COMn, # Bayes model
              family = gaussian,
              z_score ~ Config + Order + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2


withinSubPlotAvg(COMn, 'COMWork_neg', 'higher', 'Negative Center of Mass Work (J)')



extractVals(COMn, NCOMwMod, otherConfigs, baseline, 'COMWork_neg', 'higher') 
```

### Heel Contact Area - Running

```{r}
#| echo: false
#| warning: false
#| include: false 


dialTorque <- read_xlsx('C:\\Users\\milena.singletary\\OneDrive - BOA Technology Inc\\General - PFL Team\\Testing Segments\\AgilityPerformanceData\\2025_Mechanistic_WomensPanelStiffnessII_Adidas\\2025_Mech_WomensPanelStiffnessII_Adidas.xlsx')

dialTorque <- dialTorque%>%
  select(Subject, Config, R_DialTorque1)

dialTorque$Config <- factor(dialTorque$Config, allConfigs)

torqPress <- merge(Press, dialTorque, by = c('Subject', 'Config'))


###### Heel Contact

HeelCondat <- torqPress %>% 
  group_by(Subject) %>%
  filter(Movement == 'run' )%>%
  mutate(z_score = scale(heelAreaP)) %>% 
  group_by(Config)

HeelCondat<- subset(HeelCondat, HeelCondat$z_score < 2) #removing outliers  
HeelCondat<- subset(HeelCondat, HeelCondat$z_score > -2)

ggplot(data = HeelCondat, aes(x = ProxDial, fill = Config)) + geom_histogram() + facet_wrap(~Subject)



HeelMod <- brm(data = HeelCondat, # Bayes model
              family = gaussian,
              z_score ~ Config + ProxDial + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 1000, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2


withinSubPlotAvg(HeelCondat, 'heelAreaP', 'higher', 'Heel Contact Area (%)')




extractVals(HeelCondat, HeelMod, otherConfigs, baseline, 'heelAreaP', 'higher')
```

### Peak Toe Pressure - Running

```{r}
#| echo: false
#| warning: false
#| include: false 

#Peak toe press
Toedat <- Press %>% 
  group_by(Subject) %>%
  filter(Movement == 'run' )%>%
  mutate(z_score = scale(maxmaxToes)) %>% 
  group_by(Config)

Toedat<- subset(Toedat, Toedat$z_score < 2) #removing outliers  
Toedat<- subset(Toedat, Toedat$z_score > -2)

ggplot(data = Toedat, aes(x = maxmaxToes, fill = Config)) + geom_histogram() + facet_wrap(~Subject)

# Note for trail run metrics: Warmup was reduced (from 1000 to 500)
ToeMod <- brm(data = Toedat, # Bayes model
              family = gaussian,
              z_score ~ Config + (1 + Config| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 500, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)

```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2  



withinSubPlotAvg(Toedat, 'maxmaxToes', 'lower', 'Peak Toe Pressure (kPa)')



extractVals(Toedat, ToeMod, otherConfigs, baseline, 'maxmaxToes', 'lower')
```

## Static Pressures

### **Static Peak Dorsal Pressure (lower is better)**

```{r}
#| echo: false
#| warning: false
#| include: false 

#Peak dorsal pressure
pkDat <- static %>% 
  group_by(Subject) %>%
  filter(Movement == 'Standing')%>%
  mutate(z_score = scale(maxDorsalPressure)) %>% 
  group_by(Config)

pkDat<- subset(pkDat, pkDat$z_score < 2) #removing outliers  
pkDat<- subset(pkDat, pkDat$z_score > -2)

# ggplot(data = pkDat, aes(x = maxDorsalPressure, fill = Config)) + geom_histogram() + facet_wrap(~Subject)

# Note for trail run metrics: Warmup was reduced (from 1000 to 500)
pkMod <- brm(data = pkDat, # Bayes model
              family = gaussian,
              z_score ~ Config +  (1| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 500, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 

withinSubPlotAvg(pkDat, 'maxDorsalPressure', 'lower', 'Peak Dorsal Pressure (kPa)')


extractVals(pkDat, pkMod, otherConfigs, baseline, 'maxDorsalPressure', 'lower')
```

### Static Average Dorsal Pressure (higher is better)

```{r}
#| echo: false
#| warning: false
#| include: false 

#average dorsal pressure
avgDat <- static %>% 
  group_by(Subject) %>%
  filter(Movement == 'Standing')%>%
  mutate(z_score = scale(meanDorsalPressure)) %>% 
  group_by(Config)

avgDat<- subset(avgDat, avgDat$z_score < 2) #removing outliers  
avgDat<- subset(avgDat, avgDat$z_score > -2)

# ggplot(data = avgDat, aes(x = meanDorsalPressure, fill = Config)) + geom_histogram() + facet_wrap(~Subject)

# Note for trail run metrics: Warmup was reduced (from 1000 to 500)
avgMod <- brm(data = avgDat, # Bayes model
              family = gaussian,
              z_score ~ Config +  (1| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained 
              iter = 2000, warmup = 500, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)
```

```{r}
#| echo: false
#| warning: false
#| layout-ncol: 2 


withinSubPlotAvg(avgDat, 'meanDorsalPressure', 'higher', 'Average Dorsal Pressure (kPa)')



extractVals(avgDat, avgMod, otherConfigs, baseline, 'meanDorsalPressure', 'higher')

```

### Zonal Dorsal Pressures

```{r}
#| echo: false
#| warning: false
#| include: false 


#average Forefoot pressure
ffDat <- static %>% 
  group_by(Subject) %>%
  filter(Movement == 'Standing')%>%
  mutate(z_score = scale(ffDorsalPressure)) %>% 
  group_by(Config)




ggplot(data = ffDat, aes(x = ffDorsalPressure, fill = Config)) + geom_histogram() + facet_wrap(~Subject)

# Note for trail run metrics: Warmup was reduced (from 1000 to 500)
ffDatMod <- brm(data = ffDat, # Bayes model
              family = gaussian,
              z_score ~ Config +  (1| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 500, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)






withinSubPlotAvg(ffDat, 'ffDorsalPressure', 'higher', 'Average Forefoot Pressure (kPa)')



extractVals(ffDat, ffDatMod, otherConfigs, baseline, 'ffDorsalPressure', 'higher') 


#############

#average Midfoot pressure

mfDat <- static %>% 
  group_by(Subject) %>%
  filter(Movement == 'Standing')%>%
  mutate(z_score = scale(mfDorsalPressure)) %>% 
  group_by(Config)




ggplot(data = ffDat, aes(x = ffDorsalPressure, fill = Config)) + geom_histogram() + facet_wrap(~Subject)

# Note for trail run metrics: Warmup was reduced (from 1000 to 500)
mfDatMod <- brm(data = mfDat, # Bayes model
              family = gaussian,
              z_score ~ Config +  (1| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 500, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)






withinSubPlotAvg(mfDat, 'mfDorsalPressure', 'higher', 'Average Midfoot Pressure (kPa)')



extractVals(mfDat, mfDatMod, otherConfigs, baseline, 'mfDorsalPressure', 'higher') 





insDat <- static %>% 
  group_by(Subject) %>%
  filter(Movement == 'Standing')%>%
  mutate(z_score = scale(instepDorsalPressure)) %>% 
  group_by(Config)




ggplot(data = insDat, aes(x = instepDorsalPressure, fill = Config)) + geom_histogram() + facet_wrap(~Subject)

# Note for trail run metrics: Warmup was reduced (from 1000 to 500)
insDatMod <- brm(data = insDat, # Bayes model
              family = gaussian,
              z_score ~ Config +  (1| Subject), #fixed effect of configuration and time period with a different intercept and slope for each subject
              prior = c(prior(normal(0, 1), class = Intercept), #The intercept prior is set as a mean of 25 with an SD of 5 This may be interpreted as the average loading rate (but average is again modified by the subject-specific betas)
                        prior(normal(0, 1), class = b), #beta for the intercept for the change in loading rate for each configuration
                        prior(cauchy(0, 1), class = sd), #This is a regularizing prior, meaning we will allow the SD of the betas to vary across subjects
                        prior(cauchy(0, 1), class = sigma)), #overall variability that is left unexplained
              iter = 2000, warmup = 500, chains = 4, cores = 4,
              control = list(adapt_delta = .975, max_treedepth = 20),
              seed = 190831)






withinSubPlotAvg(insDat, 'instepDorsalPressure', 'higher', 'Average Instep Pressure (kPa)')



extractVals(insDat, insDatMod , otherConfigs, baseline, 'instepDorsalPressure', 'higher') 


```

```{r}
#| echo: false
#| warning: false
#| include: false 

###### For agility run combo
# LateralAgility <- 52
# 
# VerticalAgility <- 29.3
# 
# Fit <- 81.6
# 
# Qual <- 46
# 
# data <- t(c(VerticalAgility, LateralAgility, Fit, Qual))
# 
# data <- as.data.frame(data)
# 
# improvThresh<- as.data.frame(t(rep(70, 4)))
# equalThresh<- as.data.frame(t(rep(50, 4)))
# 
# min =as.data.frame(t(rep(0, 4)))
# max = as.data.frame(t(rep(100,4)))
# data <- rbind(max, min, improvThresh, equalThresh, data)
# 
# colnames(data) <- c("VerticalAgility", "LateralAgility", "Fit", "Qual")
# 
# colors <- c("#C8C9C7","#53565A", "#00966C")
# 
# create_beautiful_radarchart <- function(data, color = "#00966C", 
#                                         vlabels = colnames(data), vlcex = 0.9,
#                                         caxislabels = NULL, title = NULL, ...){
#   radarchart(
#     data, axistype = 1,
#     # Customize the polygon
#     pcol = color, pfcol = scales::alpha(color, 0.5), plwd = 2, plty = 1,
#     # Customize the grid
#     cglcol = "grey", cglty = 1, cglwd = 0.8,
#     # Customize the axis
#     axislabcol = "grey", 
#     # Variable labels
#     vlcex = vlcex, vlabels = vlabels,
#     caxislabels = caxislabels, title = title, ...
#   )
# }
# 
# 
# create_beautiful_radarchart(data = data, color = colors)
# 
# legend(x = "topright", inset = c(- 0.3, 0.2), legend = c("Threshold for confidence in improvement", "SD", "Heel Lock Config"),
#        bty = "n", pch = 20, col = colors, text.col = "black", cex = .7, pt.cex = 1)
# 
# ## This code gives a visual representation of how a shoe performed against a baseline shoe in the form of a radar plot 
# #This happens by assigning different averaged ratings to different segments 
# #You are only adding the shoe being tested to the ratings, the baseline shoe is always set to 50 for a clear comparison
# #The shoe being tested is rated by the average percentile confidence in each segment 
# ###For example, if a PFS shoe had 75% confidence in CMJ  and 50% in skater for contact time, the average rating for agility would be 62.5 -> 63 
# 
# 
# 
# #### Config DDHL
# 
# LateralAgility <- 32
# 
# VerticalAgility <- 28.3
# 
# Fit <- 48
# 
# Qual <- 85
# 
# data <- t(c(VerticalAgility, LateralAgility, Fit, Qual))
# 
# data <- as.data.frame(data)
# 
# improvThresh<- as.data.frame(t(rep(70, 4)))
# equalThresh<- as.data.frame(t(rep(50, 4)))
# 
# min =as.data.frame(t(rep(0, 4)))
# max = as.data.frame(t(rep(100,4)))
# data <- rbind(max, min, improvThresh, equalThresh, data)
# 
# colnames(data) <- c("VerticalAgility", "LateralAgility", "Fit", "Qual")
# 
# colors <- c("#C8C9C7","#53565A", "#00966C")
# 
# create_beautiful_radarchart <- function(data, color = "#00966C", 
#                                         vlabels = colnames(data), vlcex = 0.9,
#                                         caxislabels = NULL, title = NULL, ...){
#   radarchart(
#     data, axistype = 1,
#     # Customize the polygon
#     pcol = color, pfcol = scales::alpha(color, 0.5), plwd = 2, plty = 1,
#     # Customize the grid
#     cglcol = "grey", cglty = 1, cglwd = 0.8,
#     # Customize the axis
#     axislabcol = "grey", 
#     # Variable labels
#     vlcex = vlcex, vlabels = vlabels,
#     caxislabels = caxislabels, title = title, ...
#   )
# }
# 
# 
# create_beautiful_radarchart(data = data, color = colors)
# 
# legend(x = "topright", inset = c(- 0.1, 0), legend = c("threshold for confidence in improvement", "SD", "Heel Lock Solution"),
#        bty = "n", pch = 20, col = colors, text.col = "black", cex = .7, pt.cex = 1)
```
